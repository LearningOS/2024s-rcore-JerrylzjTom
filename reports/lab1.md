## 功能实现
向内核控制块信息添加了system_call_times，用于统计系统调用次数； 添加time字段， 用于记录任务第一次被调度的时长；添加flag字段，用于记录任务是否第一次被调度。

## 简答作业
### 1
SBI版本：RustSBI-QEMU Version 0.2.0-alpha.2。错误行为包括User mode 执行或访问Supervisor mode的指令或寄存器，引发IllegalInstruction的异常。
### 2
1. 
_restore使用的两种情景： 
+ 开始执行应用时，从内核态切换到用户态，此时_restore a0表示trap context栈顶 
+ 在trap handle之后，从内核态切换到用户态，此时_restore a0表示内核栈压入Trap 上下文之后的栈顶, 因为此时进入_restore, sp指向用户栈，所有需要sp <- a0, 使得sp指向内核栈，执行_restore，后特权级由S切换至U。
2.
处理了sstatus, spec, sscratch寄存器。
sscratch保存了进入trap之前的用户态sp，用于恢复用户态。
sstatus保存了进入trap前的特权级，用于ret恢复特权级
spec保存了trap发生之前执行的最后一条指令。trap执行后，设置PC为spec，继续执行后续指令。
3. x2(sp),需要基于它来找到每个寄存器应该被保存到的正确的位置。x4(tp)不需要使用。
4. sp此时指向进入trap之前用户态的sp，sscratch此时指向内核栈栈顶。
5. sret. 指令执行后，特权级从S切换至U，PC设置为spec，继续执行用户态指令；sp此时为用户栈栈顶。
6. sp此时切换为内核栈栈顶， sscratch此时为用户栈栈顶。
7. ecall

## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

《你交流的对象说明》

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

《你参考的资料说明》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。